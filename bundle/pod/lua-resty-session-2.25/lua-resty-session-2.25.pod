=encoding utf-8


=head1 lua-resty-session


B<lua-resty-session> is a secure, and flexible session library for OpenResty.


=head2 Hello World with lua-resty-session



    worker_processes  1;
    
    events {
        worker_connections  1024;
    }
    
    http {
        server {
            listen       8080;
            server_name  localhost;
            default_type text/html;
            location / {
                content_by_lua '
                    ngx.say("<html><body><a href=/start>Start the test</a>!</body></html>")
                ';
            }
            location /start {
                content_by_lua '
                    local session = require "resty.session".start()
                    session.data.name = "OpenResty Fan"
                    session:save()
                    ngx.say("<html><body>Session started. ",
                            "<a href=/test>Check if it is working</a>!</body></html>")
                ';
            }
            location /test {
                content_by_lua '
                    local session = require "resty.session".open()
                    ngx.say("<html><body>Session was started by <strong>",
                            session.data.name or "Anonymous",
                            "</strong>! <a href=/destroy>Destroy the session</a>.</body></html>")
                ';
            }
            location /destroy {
                content_by_lua '
                    local session = require "resty.session".start()
                    session:destroy()
                    ngx.say("<html><body>Session was destroyed. ",
                            "<a href=/check>Is it really so</a>?</body></html>")
                ';
            }
            location /check {
                content_by_lua '
                    local session = require "resty.session".open()
                    ngx.say("<html><body>Session was really destroyed, you are known as ",
                            "<strong>",
                            session.data.name or "Anonymous",
                            "</strong>! <a href=/>Start again</a>.</body></html>")
                ';
            }
        }
    }


=head2 Roadmap



=over


=item *

Add support for different schemes:

=over


=item *

Encrypt-and-MAC: The ciphertext is generated by encrypting the plaintext and then appending a MAC of the plaintext.

=item *

MAC-then-encrypt: The ciphertext is generated by appending a MAC to the plaintext and then encrypting everything.

=item *

Encrypt-then-MAC: The ciphertext is generated by encrypting the plaintext and then appending a MAC of the encrypted plaintext.

=item *

Authenticated Encryption with Associated Data (AEAD)

=back


=item *

Add support for HMAC plugins

=item *

Add support for C<lua-resty-nettle> for more wide variety of encryption algorithms as a plugin.

=item *

Implement cookieless server-side session support using C<ssl_session_id> as a C<session.id> (using a server-side storage).


=back


=head2 Installation


Just place L<`session.lua`|https://github.com/bungle/lua-resty-session/blob/master/lib/resty/session.lua> and L<`session`|https://github.com/bungle/lua-resty-session/tree/master/lib/resty/session> directory somewhere in your C<package.path>, under C<resty> directory. If you are using OpenResty, the default location would be C</usr/local/openresty/lualib/resty>.


=head3 Using OpenResty Package Manager (opm)



    $ opm get bungle/lua-resty-session


=head3 Using LuaRocks



    $ luarocks install lua-resty-session

LuaRocks repository for C<lua-resty-session> is located at https://luarocks.org/modules/bungle/lua-resty-session.


=head2 About The Defaults


C<lua-resty-session> does by default set session only cookies (non-persistent, and C<HttpOnly>) so that
the cookies are not readable from Javascript (not subjectible to XSS in that matter). It will also set
C<Secure> flag by default when the request was made via SSL/TLS connection. Cookies send via SSL/TLS
don't work when sent via HTTP and vice-versa (unless the checks are disabled). By default the HMAC key
is generated from session id (random bytes generated with OpenSSL), expiration time, unencrypted
data, and Nginx variables C<ssl_session_id> (if requested with TLS/SSL), C<http_user_agent> and C<scheme>.
You may also configure it to use C<remote_addr> as well by setting C<set $session_check_addr on;>
(but this may be problematic with clients behind proxies or NATs that change the remote address
between requests).

The data part is encrypted with AES-algorithm (by default it uses OpenSSL C<EVP_aes_256_cbc> and
C<EVP_sha512> functions that are provided with C<lua-resty-string>. They come pre-installed with
the default OpenResty bundle. The C<lua-resty-session> library is not tested with all the
C<resty.aes> functions (but the defaults are tested to be working). Please let me know or contact
C<lua-resty-string> project if you hit any problems with different algorithms. We also support
pluggable cipher adapters. You can also disable encryption by choosing C<none> adapter.

Session identifier length is by default 16 bytes (randomly generated data with OpenSSL
C<RAND_bytes> function). The server secret is also generated by default with this same
function and it's default length is 32 bytes. This will work until Nginx is restarted, but you
might want to consider setting your own secret using C<set $session_secret 623q4hR325t36VsCD3g567922IC0073T;>,
for example (this will work in farms installations as well, but you are then responsible for
rotating the secret). On farm installations you should also configure other session configuration
variables the same on all the servers in the farm.

Cookie parts are encoded with cookie safe Base64 encoding (we also support pluggable encoders).
Before encrypting and encoding the data part, the data is serialized with JSON encoding (so you can
use basic Lua types in data, and expect to receive them back as the same Lua types). JSON encoding
is done by the bundled OpenResty cJSON library (Lua cJSON). We do support pluggable serializers as
well, though only serializer currently supplied is JSON. Cookie's path scope is by default C</>
(meaning that it will be send to all paths in the server. The domain scope is not set by default,
and it means that the cookie will only be sent back to same domain where it originated.

For session data we do support pluggable storage adapters. The default adapter is C<cookie> that
stores data to client-side cookie. Currently we do also support a few server side storages: C<shm>
(aka a shared dictionary), C<memcache>, and C<redis>.


=head2 Notes About Turning Lua Code Cache Off


In issue (L<#15|https://github.com/bungle/lua-resty-session/issues/15>) it was raised that there may
be problems of using C<lua-resty-session> when the C<lua_code_cache> setting has been turned off.

Nginx:


    lua_code_cache off;

The problem is caused by the fact that by default we do generate session secret automatically with
a random generator (on first use of the library). If the code cache is turned off, we regenerate
the secret on each request. That will invalidate the cookies aka making sessions non-functioning.
The cure for this problem is to define the secret in Nginx or in Lua code (it is a good idea to
always have session secret defined).

Nginx:


    set $session_secret 623q4hR325t36VsCD3g567922IC0073T;

Lua:


    local session = require "resty.session".start{ secret = "623q4hR325t36VsCD3g567922IC0073T" }
    -- or
    local session = require "resty.session".new()
    session.secret = "623q4hR325t36VsCD3g567922IC0073T"


=head2 Pluggable Session Strategies


Strategies can be a bit cumbersome to do with just configuration, and that's why you can
implement them with the code. Currently C<lua-resty-session> comes with two strategies:


=over


=item *

C<default> — the default strategy (original implementation)

=item *

C<regenerate> — similar to default strategy, but does not use C<expires> with C<HMAC>
functions, and instead generates a new session identifier on each C<save>.


=back

The C<default> one has been here from the beginning, but recently I got information about
use case of Javascript application with parallel asynchronous queries, where the session
was saved to a database with a custom storage adapter using C<header_filter> phase, which resulted
the need to use the asynchronous C<ngx.timer>. And that resulted that the JS XHR requests may
have sent an old cookie, or perhaps a new cookie that was not yet found in db because of async
timer. This resulted issues because cryptographic functions in C<default> strategy used C<expires>,
and every time you saved a cookie it got a new C<expiry>. The C<regenerate> adapter does not use
C<expiry> anymore, but it instead generates a new C<session id> on each C<save> call. This makes
a new row in a database while the previous C<session> will still function. If your storage adapter
implements C<ttl> the C<regenerate> strategy will call that with the old id and C<10> seconds
of C<ttl>. C<default> strategy is still adequate if you use C<cookie> storage adapter as that
is not issue with it, but if using server side storage adapter like C<redis> or C<memcache>
you may want to consider using C<regenerate> if you have a heavily JS based application with
a lot of asynchronous queries at the same time. This issue happens usually when session
is about to be renewed, so it is quite rare even when using C<default> strategy.

Strategy can be selected with configuration (if no configuration is present, the C<default> strategy is picked up):


    set $session_strategy regenerate;

To implement a custom strategy, please checkout the existing ones.


=head2 Pluggable HMAC Algorithms


If your strategy happens to be using C<HMAC>, like the C<default> and C<regenerate> ones do,
you can tell them what C<HMAC> algorithm to use. At the moment only C<HMAC SHA1> is available
as that comes with OpenResty and works without additional dependencies. You may implement
your own custom HMAC algorithms (preferrably binding to some existing crypto library,
such as OpenSSL), and the strategies will pick up from there.

HMAC can be selected with configuration (if no configuration is present, the C<sha1> strategy is picked up):


    set $session_hmac sha1;


=head2 Pluggable Storage Adapters


With version 2.0 we started to support pluggable session data storage adapters. We do currently have
support for these backends:


=over


=item *

C<cookie> aka Client Side Cookie (this is the default adapter)

=item *

C<shm> aka Lua Shared Dictionary

=item *

C<memcache> aka Memcached Storage Backend (thanks L<@zandbelt|https://github.com/zandbelt>)

=item *

C<redis> aka Redis Backend


=back

Here are some comparisons about the backends:

|                               | cookie | shm  | memcache | redis | dshm |
| :---------------------------- | :----: | :--: | :------: | :---: | :---: |
| Stateless                     | ✓      |      |          |       |       |
| Lockless                      | ✓      | ¹    | ¹        | ¹     | ✓     |
| Works with Web Farms          | ✓      |      | ✓        | ✓     | ✓     |
| Session Data Stored on Client | ✓      |      |          |       |       |
| Zero Configuration            | ✓      |      |          |       |       |
| Extra Dependencies            |        |      | ✓        | ✓     | ✓     |
| Extra Security ²              |        | ✓    | ✓        | ✓     | ✓     |

¹ Can be configured lockless.

² HMAC is stored on a client but the data is stored on a server. That means that you are unable to edit
cookie if you cannot edit server side storage as well, and vice-versa.

The storage adapter can be selected from Nginx config like this:


    set $session_storage shm;

Or with Lua code like this:


    local session = require "resty.session".new()
    -- After new you cannot specify storage as a string, you need to give actual implementation
    session.storage = require "resty.session.storage.shm"
    -- or
    local session = require "resty.session".new({ storage = "shm" })


=head4 Cookie Storage Adapter


Cookie storage adapter is the default adapter that is used if storage adapter has not been configured. Cookie
adapter does not have any settings.

Cookie adapter can be selected with configuration (if no configuration is present, the cookie adapter is picked up):


    set $session_storage cookie;

B<NOTE:>

If you store large amounts of data in a cookie, this library will automatically split the cookies to 4k chars chunks. With large cookies, you may need to adjust your Nginx configuration to accept large client header buffers. E.g.:


    large_client_header_buffers 4 16k;


=head4 Shared Dictionary Storage Adapter


Shared dictionary uses OpenResty shared dictionary and works with multiple worker processes, but it isn't a good
choice if you want to run multiple separate frontends. It is relatively easy to configure and has some added
benefits on security side compared to C<cookie>, although the normal cookie adapter is quite secure as well.
For locking the C<shm> adapter uses C<lua-resty-lock>.

Shared dictionary adapter can be selected with configuration:


    set $session_storage shm;

But for this to work, you will also need a storage configured for that:


    http {
       lua_shared_dict sessions 10m;
    }

Additionally you can configure the locking and some other things as well:


    set $session_shm_store         sessions;
    set $session_shm_uselocking    on;
    set $session_shm_lock_exptime  30;
    set $session_shm_lock_timeout  5;
    set $session_shm_lock_step     0.001;
    set $session_shm_lock_ratio    2;
    set $session_shm_lock_max_step 0.5;

The keys stored in shared dictionary are in form:

C<{session id}> and C<{session id}.lock>.


=head4 Memcache Storage Adapter


Memcache storage adapter stores the session data inside Memcached server.
It is scalable and works with web farms. 

Memcache adapter can be selected with configuration:


    set $session_storage memcache;

Additionally you can configure Memcache adapter with these settings:


    set $session_memcache_prefix        sessions;
    set $session_memcache_socket        unix:///var/run/memcached/memcached.sock;
    set $session_memcache_host          127.0.0.1;
    set $session_memcache_port          11211;
    set $session_memcache_uselocking    on;
    set $session_memcache_spinlockwait  10000;
    set $session_memcache_maxlockwait   30;
    set $session_memcache_pool_timeout  45;
    set $session_memcache_pool_size     10;

The keys stored in Memcached are in form:

C<{prefix}:{session id}> and C<{prefix}:{session id}.lock>.


=head4 Redis Storage Adapter


Redis storage adapter stores the session data inside Redis server.
It is scalable and works with web farms. 

Redis adapter can be selected with configuration:


    set $session_storage redis;

Additionally you can configure Redis adapter with these settings:


    set $session_redis_prefix        sessions;
    set $session_redis_socket        unix:///var/run/redis/redis.sock;
    set $session_redis_host          127.0.0.1;
    set $session_redis_port          6379;
    set $session_redis_auth          password;
    set $session_redis_uselocking    on;
    set $session_redis_spinlockwait  10000;
    set $session_redis_maxlockwait   30;
    set $session_redis_pool_timeout  45;
    set $session_redis_pool_size     10;

The keys stored in Redis are in form:

C<{prefix}:{session id}> and C<{prefix}:{session id}.lock>.


=head4 DSHM Storage Adapter


DSHM storage adapter stores the session data inside Distributed Shared Memory server based on Vertx and Hazelcast.
It is scalable and works with web farms. 

The DSHM lua library and the DSHM servers should be installed conforming with the documentation L<here|https://github.com/grrolland/ngx-distributed-shm/blob/master/README.md>.  

DSHM adapter can be selected with configuration:


    set $session_storage dshm;

Additionally you can configure DSHM adapter with these settings:


    set $session_dshm_store              sessions;
    set $session_dshm_host               127.0.0.1;
    set $session_dshm_port               4321;
    set $session_dshm_pool_idle_timeout  1000;
    set $session_dshm_pool_size          100;

The keys stored in DSHM are in form:

C<{store}::{session id}>

The store represents the cache region in DSHM


=head4 Implementing a Storage Adapter


It is possible to implement additional storage adapters using the plugin architecture in C<lua-resty-session>.

You need to implement at least these APIs:


=over


=item *

C<table adapter.new(opts)>

=item *

C<id, expires, data, hmac adapter:open(cookie, lifetime)>

=item *

C<cookie adapter:save(id, expires, data, hmac)>


=back

There are a few additional hooks that you may want to attach:


=over


=item *

C<ok, error adapter:start(id)>

=item *

C<ok, error adapter:close(id)>

=item *

C<ok, error adapter:destroy(id)>

=item *

C<ok, error adapter:ttl(id, ttl)>


=back

You have to place your adapter inside C<resty.session.storage> for auto-loader to work.

To configure session to use your adapter, you can do so with Nginx configuration (or in Lua code):


    # Just an example. Pull request for MySQL support are greatly welcomed.
    set $session_storage mysql;


=head2 Pluggable Ciphers


With version 2.1 we started to support pluggable ciphers. We currently have support for these ciphers:


=over


=item *

C<aes> aka AES encryption / decryption using C<lua-resty-string>'s AES library (the default).

=item *

C<none> aka no encryption or decryption is done.


=back

The cipher adapter can be selected from Nginx config like this:


    set $session_cipher aes;

Or with Lua code like this:


    local session = require "resty.session".start{ cipher = "aes" }


=head4 AES Cipher


AES Cipher uses C<lua-resty-string>'s (an OpenResty core library) AES implementation
(bindings to OpenSSL) for encryption.

AES adapter can be selected with configuration:


    set $session_cipher aes;

Additionally you can configure Memcache adapter with these settings:


    set $session_aes_size   256;
    set $session_aes_mode   "cbc";
    set $session_aes_hash   "sha512";
    set $session_aes_rounds 1;

Here follows the description of each setting:

B<size>

C<session.aes.size> holds the size of the cipher (C<lua-resty-string> supports AES in C<128>, C<192>,
and C<256> bits key sizes). See C<aes.cipher> function in C<lua-resty-string> for more information.
By default this will use C<256> bits key size. This can be configured with Nginx
C<set $session_aes_size 256;>.

B<mode>

C<session.aes.mode> holds the mode of the cipher. C<lua-resty-string> supports AES in C<ecb>, C<cbc>,
C<cfb1>, C<cfb8>, C<cfb128>, C<ofb>, and C<ctr> modes (ctr mode is not available with 256 bit keys).
See C<aes.cipher> function in C<lua-resty-string> for more information. By default C<cbc> mode is
used. This can be configured with Nginx C<set $session_aes_mode cbc;>.

B<hash>

C<session.aes.hash> is used in ecryption key, and iv derivation (see: OpenSSL
L<EVP_BytesToKey|https://www.openssl.org/docs/crypto/EVP_BytesToKey.html>). By default C<sha512> is
used but C<md5>, C<sha1>, C<sha224>, C<sha256>, and C<sha384> are supported as well in C<lua-resty-string>.
This can be configured with Nginx C<set $session_aes_hash sha512;>.

B<rounds>

C<session.aes.rounds> can be used to slow-down the encryption key, and iv derivation. By default
this is set to C<1> (the fastest). This can be configured with Nginx C<set $session_aes_rounds 1;>.


=head4 None Cipher


None cipher disables encryption of the session data. This can be handy if you want to
debug things or want you session management as light as possible, or perhaps share the
session data with some other process without having to deal with encryption key management.
In general it is better to have encryption enabled in a production.

None adapter can be selected with configuration:


    set $session_cipher none;

There isn't any settings for None adapter as it is basically a no-op adapter.


=head4 Implementing a Cipher Adapter


If you want to write your own cipher adapter, you need to implement these three methods:


=over


=item *

C<table adapter.new(opts)>

=item *

C<string adapter:encrypt(data, key, iv or salt, associated data)>

=item *

C<string adapter:decrypt(ciphertext, key, iv or salt, associated data)>


=back

If you do not use say iv or associated data in your cipher, you can ignore them.

You have to place your adapter inside C<resty.session.ciphers> for auto-loader to work.


=head2 Pluggable Serializers


Currently we only support JSON serializer, but there is a plugin architecture that you can use to
plugin your own serializer. The serializer is used to serialize session data in a form that can be
later deserialized and stored in some of our supported storages.

The supported serializer names are:


=over


=item *

C<json>


=back

You need only to implement two functions to write an adapter:


=over


=item *

C<string adapter.serialize(table)>

=item *

C<table adapter.deserialize(string)>


=back

You have to place your adapter inside C<resty.session.serializers> for auto-loader to work.

To configure session to use your adapter, you can do so with Nginx configuration (or in Lua code):


    set $session_serializer json;


=head2 Pluggable Encoders


Cookie data needs to be encoded in cookie form before it is send to client. We support
two encoding methods by default: modified cookie friendly base-64, and base-16 (or hexadecimal encoding).

The supported encoder names are:


=over


=item *

C<base64>

=item *

C<base16> or C<hex>


=back

If you want to write your own encoder, you need to implement these two methods:


=over


=item *

C<string adapter.encode(string)>

=item *

C<string adapter.decode(string)>


=back

You have to place your adapter inside C<resty.session.encoders> for auto-loader to work.

To configure session to use your adapter, you can do so with Nginx configuration (or in Lua code):


    set $session_encoder base64;


=head2 Pluggable Session Identifier Generators


With version 2.12 we started to support pluggable session identifier generators in C<lua-resty-session>.
Right now we support only one type of generator, and that is:


=over


=item *

C<random>


=back

If you want to write your own session identifier generator, you need to implement one function:


=over


=item *

C<string function(config)>


=back

(the C<config> is actually a C<session> instance)

You have to place your generator inside C<resty.session.identifiers> for auto-loader to work.

To configure session to use your generator, you can do so with Nginx configuration (or in Lua code):


    set $session_identifier_generator random;


=head4 Random Sesssion Identifier Generator


Random generator uses C<lua-resty-string>'s (an OpenResty core library) OpenSSL based cryptographically
safe random generator.

Random generator can be selected with configuration:


    set $session_identifier random;

Additionally you can configure Random generator with these settings:


    set $session_random_length 16;

Here follows the description of each setting:

B<length>

C<session.random.length> holds the length of the C<session.id>. By default it is 16 bytes.
This can be configured with Nginx C<set $session_random_length 16;>.


=head2 Lua API



=head3 Functions and Methods



=head4 table session.new(opts or nil)


With this function you can create a new session table (i.e. the actual session instance). This allows
you to generate session table first, and set invidual configuration before calling C<session:open()> or
C<session:start()>. You can also pass in C<opts> Lua C<table> with the configurations.


    local session = require "resty.session".new()
    -- set the configuration parameters before calling start
    session.cookie.domain = ".mydomain.com"
    -- call start before setting session.data parameters
    session:start()
    session.data.uid = 1
    -- save session and update the cookie to be sent to the client
    session:save()

This is equivalent to this:


    local session = require "resty.session".new{ cookie = { domain = ".mydomain.com" } }
    session:start()
    session.data.uid = 1
    session:save()

As well as with this:


    local session = require "resty.session".start{ cookie = { domain = ".mydomain.com" } }
    session.data.uid = 1
    session:save()


=head4 table, boolean session.open(opts or nil)


With this function you can open a new session. It will create a new session Lua C<table> on each call (unless called with
colon C<:> as in examples above with C<session.new>). Calling this function repeatedly will be a no-op when using colon C<:>.
This function will return a (new) session C<table> as a result. If the session cookie is supplied with user's HTTP(S)
client then this function validates the supplied session cookie. If validation is successful, the user supplied session
data will be used (if not, a new session is generated with empty data). You may supply optional session configuration
variables with C<opts> argument, but be aware that many of these will only have effect if the session is a fresh session
(i.e. not loaded from user supplied cookie). The second C<boolean> return argument will be C<true> if the user
client send a valid cookie (meaning that session was already started on some earlier request), and C<false> if the
new session was created (either because user client didn't send a cookie or that the cookie was not a valid one). This
function will not set a client cookie. You need to call C<session:start()> to really start the session. This open function
is mainly used if you only want to read data and avoid automatically sending a cookie (see also issue
L<#12|https://github.com/bungle/lua-resty-session/issues/12>). But be aware that this doesn't update cookie
expiration time stored in a cookie.


    local session = require "resty.session".open()
    -- Set some options (overwriting the defaults or nginx configuration variables)
    local session = require "resty.session".open{ random = { length = 32 }}
    -- Read some data
    if session.present then
        ngx.print(session.data.uid)
    end
    -- Now let's really start the session
    -- (session.started will be always false in this example):
    if not session.started then 
        session:start()
    end
    session.data.greeting = "Hello, World!"
    session:save()


=head4 table, boolean session.start(opts or nil)


With this function you can start a new session. It will create a new session Lua C<table> on each call (unless called with
colon C<:> as in examples above with C<session.new>). Right now you should only start session once per request as calling
this function repeatedly will overwrite the previously started session cookie and session data. This function will return
a (new) session C<table> as a result. If the session cookie is supplied with user's HTTP(S) client then this function
validates the supplied session cookie. If validation is successful, the user supplied session data will be used
(if not, a new session is generated with empty data). You may supply optional session configuration variables
with C<opts> argument, but be aware that many of these will only have effect if the session is a fresh session
(i.e. not loaded from user supplied cookie). This function does also manage session cookie renewing configured
with C<$session_cookie_renew>. E.g. it will send a new cookie with a new expiration time if the following is
met C<< session.expires - now < session.cookie.renew or session.expires > now + session.cookie.lifetime >>. The second
C<boolean> return argument will be C<true> if the user client send a valid cookie (meaning that session was already
started on some earlier request), and C<false> if the new session was created (either because user client didn't send
a cookie or that the cookie was not a valid one). On error this will return nil and error message.


    local session = require "resty.session".start()
    -- Set some options (overwriting the defaults or nginx configuration variables)
    local session = require "resty.session".start{ random = { length = 32 }}


=head4 boolean, string session:regenerate(flush or nil)


This function regenerates a session. It will generate a new session identifier (C<session.id>) and optionally
flush the session data if C<flush> argument evaluates C<true>. It will automatically call C<session:save> which
means that a new expires flag is set on the cookie, and the data is encrypted with the new parameters. With
client side sessions (C<cookie> storage adapter) this overwrites the current cookie with a new one (but it
doesn't invalidate the old one as there is no state held on server side - invalidation actually happens when
the cookie's expiration time is not valid anymore). This function returns a boolean value if everything went
as planned. If not it will return error string as a second return value.


    local session = require "resty.session".start()
    session:regenerate()
    -- Flush the current data
    session:regenerate(true)


=head4 boolean, string session:save([close = true])


This function saves the session and sends (not immediate though, as actual sending is handled by Nginx/OpenResty)
a new cookie to client (with a new expiration time and encrypted data). You need to call this function whenever
you want to save the changes made to C<session.data> table. It is advised that you call this function only once
per request (no need to encrypt and set cookie many times). This function returns a boolean value if everything
went as planned. If not it will return error string as a second return value. Optionally you may pass C<false>
to this method, if you don't want to close the session just yet, but just to save the data.


    local session = require "resty.session".start()
    session.data.uid = 1
    session:save()


=head4 boolean, string session:close()


This function is mainly usable with storages that implement C<locking> as calling this with e.g. C<cookie> storage
does not do anything else than set C<session.closed> to C<true>.


=head4 boolean session:destroy()


This function will immediately set session data to empty table C<{}>. It will also send a new cookie to
client with empty data and Expires flag C<Expires=Thu, 01 Jan 1970 00:00:01 GMT> (meaning that the client
should remove the cookie, and not send it back again). This function returns a boolean value if everything went
as planned.


    local session = require "resty.session".start()
    session:destroy()


=head4 session:hide()


Sometimes, when you are using C<lua-resty-session> in reverse proxy, you may want to hide the session
cookies from the upstream server. To do that you can call C<session:hide()>.


    local session = require "resty.session".start()
    session:hide()


=head3 Fields



=head4 string session.id


C<session.id> holds the current session id. By default it is 16 bytes long (raw binary bytes).
It is automatically generated.


=head4 boolean session.present


C<session.present> can be used to check if the session that was opened with C<session.open> or C<session.start>
was really a one the was received from a client. If the session is a new one, this will be false.


=head4 boolean session.opened


C<session.opened> can be used to check if the C<session:open()> was called for the current session
object.


=head4 boolean session.started


C<session.started> can be used to check if the C<session:start()> was called for the current session
object.


=head4 boolean session.destroyed


C<session.destroyed> can be used to check if the C<session:destroy()> was called for the current session
object. It will also set C<session.opened>, C<session.started>,  and C<session.present> to false.


=head4 boolean session.closed


C<session.closed> can be used to check if the C<session:close()> was called for the current session
object.


=head4 string session.key


C<session.key> holds the HMAC key. It is automatically generated. Nginx configuration like
C<set $session_check_ssi on;>, C<set $session_check_ua on;>, C<set $session_check_scheme on;> and C<set $session_check_addr on;>
will have effect on the generated key.


=head4 table session.data


C<session.data> holds the data part of the session cookie. This is a Lua C<table>. C<session.data>
is the place where you store or retrieve session variables. When you want to save the data table,
you need to call C<session:save> method.

B<Setting session variable:>


    local session = require "resty.session".start()
    session.data.uid = 1
    session:save()

B<Retrieving session variable (in other request):>


    local session = require "resty.session".open()
    local uid = session.data.uid


=head4 number session.expires


C<session.expires> holds the expiration time of the session (expiration time will be generated when
C<session:save> method is called).


=head4 string session.secret


C<session.secret> holds the secret that is used in keyed HMAC generation.


=head4 boolean session.cookie.persistent


C<session.cookie.persistent> is by default C<false>. This means that cookies are not persisted between browser sessions
(i.e. they are deleted when the browser is closed). You can enable persistent sessions if you want to by setting this
to C<true>. This can be configured with Nginx C<set $session_cookie_persistent on;>.


=head4 number session.cookie.discard


C<session.cookie.discard> holds the time in seconds how of long you want to keep old cookies alive when
using C<regenerate> session strategy. This can be configured with Nginx C<set $session_cookie_discard 10;>
(10 seconds is the default value). This works only with server side session storage adapters and when
using C<regenerate> strategy (perhaps your custom strategy could utilize this too).


=head4 number session.cookie.renew


C<session.cookie.renew> holds the minimun seconds until the cookie expires, and renews cookie automatically
(i.e. sends a new cookie with a new expiration time according to C<session.cookie.lifetime>). This can be configured
with Nginx C<set $session_cookie_renew 600;> (600 seconds is the default value).


=head4 number session.cookie.lifetime


C<session.cookie.lifetime> holds the cookie lifetime in seconds in the future. By default this is set
to 3,600 seconds. This can be configured with Nginx C<set $session_cookie_lifetime 3600;>. This does not
set cookie's expiration time on session only (by default) cookies, but it is used if the cookies are
configured persistent with C<session.cookie.persistent == true>. See also notes about
L<ssl_session_timeout>.


=head4 string session.cookie.path


C<session.cookie.path> holds the value of the cookie path scope. This is by default permissive C</>. You
may want to have a more specific scope if your application resides in different path (e.g. C</forums/>).
This can be configured with Nginx C<set $session_cookie_path /forums/;>.


=head4 string session.cookie.domain


C<session.cookie.domain> holds the value of the cookie domain. By default this is automatically set using
Nginx variable C<host>. This can be configured with Nginx C<set $session_cookie_domain openresty.org;>.
For C<localhost> this is omitted.


=head4 string session.cookie.samesite


C<session.cookie.samesite> holds the value of the cookie SameSite flag. By default we do use value of C<Lax>.
The possible values are C<Lax>, C<Strict>, and C<off>. Actually, setting this parameter anything else than
C<Lax> or C<Strict> will turn this off (but in general, you shouldn't do it). If you want better protection
against Cross Site Request Forgery (CSRF), set this to C<Strict>. Default value of C<Lax> gives you quite a
good protection against CSRF, but C<Strict> goes even further.


=head4 boolean session.cookie.secure


C<session.cookie.secure> holds the value of the cookie C<Secure> flag. meaning that when set the client will
only send the cookie with encrypted TLS/SSL connection. By default the C<Secure> flag is set on all the
cookies where the request was made through TLS/SSL connection. This can be configured and forced with
Nginx C<set $session_cookie_secure on;>.


=head4 boolean session.cookie.httponly


C<session.cookie.httponly> holds the value of the cookie C<HttpOnly> flag. By default this is enabled,
and I cannot think of an situation where one would want to turn this off. By keeping this on you can
prevent your session cookies access from Javascript and give some safety of XSS attacks. If you really
want to turn this off, this can be configured with Nginx C<set $session_cookie_httponly off;>.


=head4 string session.cookie.delimiter


C<session.cookie.delimiter> is used to configure how the different parts of the data stored in a cookie are
delimited. By default it is a pipe character, C<|>. It is up to storage adapter to decide if this configuration
parameter is used.


=head4 string session.cookie.maxsize


C<session.cookie.maxsize> is used to configure maximum size of a single cookie. This value is used to split a
large cookie into chunks. By default it is C<4000> bytes of serialized and encoded data which does not count
the cookie name and cookie flags. If you expect your cookies + flags be more than e.g. C<4096> bytes, you
should reduce the C<session.cookie.maxsize> so that a single cookie fits into C<4096> bytes because otherwise
the user-agent may ignore the cookie (being too big).


=head4 number session.cookie.chunks


C<session.cookie.chunks> should be used as a read only property to determine how many separate cookies was
used for a session. Usually this is C<1>, but if you are using a C<cookie> storage backend and store a lot
of data in session, then the cookie is divided to C<n> chunks where each stores data containing 4.000 bytes
(the last one 4000 or less). This was implemented in version 2.15.


=head4 boolean session.check.ssi


C<session.check.ssi> is additional check to validate that the request was made with the same SSL
session as when the original cookie was delivered. This check is enabled by default on releases prior 2.12
on non-persistent sessions and disabled by default on persistent sessions and on releases 2.12 and later.
Please note that on TLS with TLS Tickets enabled, this will be empty) and not used. This is discussed on issue #5
(https://github.com/bungle/lua-resty-session/issues/5). You can disable TLS tickets with Nginx configuration:


    ssl_session_tickets off;


=head4 boolean session.check.ua


C<session.check.ua> is additional check to validate that the request was made with the same user-agent browser string
as where the original cookie was delivered. This check is enabled by default.


=head4 boolean session.check.addr


C<session.check.addr> is additional check to validate that the request was made from the same remote ip-address
as where the original cookie was delivered. This check is disabled by default.


=head4 boolean session.check.scheme


C<session.check.scheme> is additional check to validate that the request was made using the same protocol 
as the one used when the original cookie was delivered. This check is enabled by default.


=head4 number session.cipher.size (deprecated in 2.1 and removed in 2.2, use session.aes.size)


C<session.cipher.size> holds the size of the cipher (C<lua-resty-string> supports AES in C<128>, C<192>,
and C<256> bits key sizes). See C<aes.cipher> function in C<lua-resty-string> for more information.
By default this will use C<256> bits key size. This can be configured with Nginx
C<set $session_cipher_size 256;>.


=head4 string session.cipher.mode (deprecated in 2.1 and removed in 2.2, use session.aes.mode)


C<session.cipher.mode> holds the mode of the cipher. C<lua-resty-string> supports AES in C<ecb>, C<cbc>,
C<cfb1>, C<cfb8>, C<cfb128>, C<ofb>, and C<ctr> modes (ctr mode is not available with 256 bit keys).
See C<aes.cipher> function in C<lua-resty-string> for more information. By default C<cbc> mode is
used. This can be configured with Nginx C<set $session_cipher_mode cbc;>.


=head4 function session.cipher.hash (deprecated in 2.1 and removed in 2.2, use session.aes.hash)


C<session.cipher.hash> is used in ecryption key, and iv derivation (see: OpenSSL
L<EVP_BytesToKey|https://www.openssl.org/docs/crypto/EVP_BytesToKey.html>). By default C<sha512> is
used but C<md5>, C<sha1>, C<sha224>, C<sha256>, and C<sha384> are supported as well in C<lua-resty-string>.
This can be configured with Nginx C<set $session_cipher_hash sha512;>.


=head4 number session.cipher.rounds (deprecated in 2.1 and removed in 2.2, use session.aes.rounds)


C<session.cipher.rounds> can be used to slow-down the encryption key, and iv derivation. By default
this is set to C<1> (the fastest). This can be configured with Nginx C<set $session_cipher_rounds 1;>.


=head2 Nginx Configuration Variables


You can set default configuration parameters directly from Nginx configuration. It's B<IMPORTANT> to understand
that these are read only once (not on every request), for performance reasons. This is especially important if
you run multiple sites (with different configurations) on the same Nginx server. You can of course set the common
parameters on Nginx configuration even on that case. But if you are really supporting multiple site with different
configurations (e.g. different C<session.secret> on each site), you should set these in code (see: C<session.new>
and C<session.start>).

Please note that Nginx has also its own SSL/TLS caches and timeouts. Especially note C<ssl_session_timeout> if you
are running services over SSL/TLS as this will end sessions regardless of C<session.cookie.lifetime>. Please adjust
that accordingly or disable C<ssl_session_id> check C<session.check.ssi = false> (in code) or
C<set $session_check_ssi off;> (in Nginx configuration). As of 2.12 checking SSL session identifier check
(C<$session_check_ssi> / C<session.check.ssi>) is disabled by default because it was not reliable (most servers use
session tickets now), and it usually needed extra configuration.

You may want to add something like this to your Nginx SSL/TLS config (quite a huge cache in this example, 1 MB is
about 4.000 SSL sessions):


    ssl_session_cache shared:SSL:100m;
    ssl_session_timeout 60m;

Also note that the C<ssl_session_id> may be C<null> if the TLS tickets are enabled. You can disable tickets in Nginx
server with the configuration below:


    ssl_session_tickets off;

Right now this is a workaround and may change in a future if we find alternative ways to have the added security
that we have with C<ssl_session_id> with TLS tickets too. While TLS tickets are great, they also have effect on
(Perfect) Forward Secrecy, and it is adviced to disable tickets until the problems mentioned in
L<The Sad State of Server-Side TLS Session Resumption Implementations|https://timtaubert.de/blog/2014/11/the-sad-state-of-server-side-tls-session-resumption-implementations/>
article are resolved.

Here is a list of C<lua-resty-session> related Nginx configuration variables that you can use to control
C<lua-resty-session>:


    set $session_name              session;
    set $session_secret            623q4hR325t36VsCD3g567922IC0073T;
    set $session_strategy          default;
    set $session_storage           cookie;
    set $session_hmac              sha1;
    set $session_cipher            aes;
    set $session_encoder           base64;
    set $session_serializer        json;
    set $session_cookie_persistent off;
    set $session_cookie_discard    10;
    set $session_cookie_renew      600;
    set $session_cookie_lifetime   3600;
    set $session_cookie_path       /;
    set $session_cookie_domain     openresty.org;
    set $session_cookie_samesite   Lax;
    set $session_cookie_secure     on;
    set $session_cookie_httponly   on;
    set $session_cookie_delimiter  |;
    set $session_cookie_maxsize    4000;
    set $session_check_ssi         off;
    set $session_check_ua          on;
    set $session_check_scheme      on;
    set $session_check_addr        off;
    set $session_random_length     16;
    set $session_aes_mode          cbc;
    set $session_aes_size          256;
    set $session_aes_hash          sha512;
    set $session_aes_rounds        1;
    # this is removed in 2.12, use session_random_length instead:
    set $session_identifier_length 16;
    # these are deprecated in 2.1 and removed in 2.2, use session_aes_* instead:
    set $session_cipher_mode       cbc;
    set $session_cipher_size       256;
    set $session_cipher_hash       sha512;
    set $session_cipher_rounds     1;


=head2 Changes


The changes of every release of this module is recorded in L<Changes.md|https://github.com/bungle/lua-resty-session/blob/master/Changes.md> file.


=head2 See Also



=over


=item *

L<lua-resty-route|https://github.com/bungle/lua-resty-route> — Routing library

=item *

L<lua-resty-reqargs|https://github.com/bungle/lua-resty-reqargs> — Request arguments parser

=item *

L<lua-resty-template|https://github.com/bungle/lua-resty-template> — Templating engine

=item *

L<lua-resty-validation|https://github.com/bungle/lua-resty-validation> — Validation and filtering library


=back


=head2 License


C<lua-resty-session> uses two clause BSD license.


    Copyright (c) 2014 – 2019 Aapo Talvensaari
    All rights reserved.
    
    Redistribution and use in source and binary forms, with or without modification,
    are permitted provided that the following conditions are met:
    
    * Redistributions of source code must retain the above copyright notice, this
      list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright notice, this
      list of conditions and the following disclaimer in the documentation and/or
      other materials provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
